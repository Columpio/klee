* ~ExecutionState~
- Execution state itself
- Owned and mutated by ~Executor~
- Given a pointer to to ~Searcher~, searchers should not ideally mutate an ES.
- Can have multiple targets so searchers can base their choice on that
- Targets set and unset by ~Executor~
- Can be isolated ???

** TODO Clearly define ways to produce clean states at arbitrary execution points.
** TODO Group ~ExecutionState~ attributes according to entities that modify them.

* ~(Meta)Searcher~
- Multiple searcher approach replaces regular ~Searcher~, ~BidirectionalSearcher~
  is a special case of that.  
- Subsearchers are designed to be independent, it is the metasearcher's job
  to decide what to do.
- Guided subsearchers must be in sync with the targets of an ~ExecutionState~,
  maybe decouple targets and ~ExecutionStates~?

** TODO Refactor ~Searcher~ into multisearcher approach.
To do that, the searcher has to return Action and accept Result from the
executor. As of now, Action has 3 options: Forward, Backward, Init. The
searcher  (metasearcher) uses its subsearchers to make a decision and return
Action  to the executor. (The action might contain metadata or should we
delegate  searcher updates to the executor? Basically, we are choosing whether
the solver or the searcher is in charge of strategy. I think the right thing
to do would be to have the metadata and let the searcher update its
subcomponents, it would allow for Executor to focus only on things regarding
execution, as it seems to be now. Also, ExecutionState contains targets,
and targets must be managed by the searcher. (Need to find a solution here.))

** TODO Define ~Action~ and ~Result~ classes (or hierarchies).

** TODO Come up with ways to set initial targets.
- Random?
- Ends/Beginnings of functions
- Allow instrumenting with a special function?

* ~Executor~
- Should only provide means to execute, not a class that changes often. The
  execution is driven by the chosen searcher. (Correct? What about PDR?)
- Do we even need seeds if we have function summaries?

** TODO Refactor ~Executor~ according to the refactor of ~Searcher~.
- Replace the searcher attribute in the executor by using
  a generalized (meta)searcher.

** TODO Inspect ~BidirectionalExecutor~ and leave out what is not needed.
- Consider breaking it into subtools to make reasoning simpler.
- Replace ~BaseExecutor~ with this.

** TODO Inspect main and transfer some of the logic into ~Executor~.

* Searcher
** TODO Refactor base searchers to return ~Action~ and accept ~Result~.

* Why cannot ~PForest~ support more than %d RandomPathSearchers?
- [[./lib/Core/PForest.h]]
- Line 36

* TODO Learn the codebase

* DONE Integrate ~KTestJSON~

* VERIFY Write pob-based test generation

* FEEDBACK Check statistics
- Some stats might be broken due to instructions being executed in isolation

* FEEDBACK Fix and integrate ~isReadFromSymbolicArray~
- Discuss second use of ~isReadFromSymbolicArray~
